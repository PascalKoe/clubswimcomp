use std::{collections::HashMap, time::Duration};

use anyhow::Context;
use tracing::instrument;

/// Output format to be generated by the Typst compiler
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TypstOutput {
    Pdf,
    Png,
    Svg,
}

impl TypstOutput {
    fn as_cli_arg(&self) -> &'static str {
        match self {
            TypstOutput::Pdf => "pdf",
            TypstOutput::Png => "png",
            TypstOutput::Svg => "svg",
        }
    }
}

#[derive(Debug, Clone)]
pub struct TypstCompiler {
    typst_bin: String,
    working_dir: String,
}

impl TypstCompiler {
    pub fn new(typst_bin: String, working_dir: String) -> Self {
        Self {
            typst_bin,
            working_dir,
        }
    }

    /// Compile a typst template to the given output format.
    ///
    /// # Parameters:
    /// - `template` - The typst template
    /// - `output_format` - The format to compile the document to
    /// - `inputs` - List of key-value pairs accessible in typst using `sys.inputs.<key>`
    #[instrument]
    pub async fn compile(
        &self,
        template_path: &str,
        output_format: TypstOutput,
        inputs: &HashMap<String, String>,
    ) -> anyhow::Result<Vec<u8>> {
        use std::process::Stdio;
        use tokio::process::Command;

        let args = build_cli_args(template_path, output_format, inputs);

        let typst_process = Command::new(&self.typst_bin)
            .env_clear()
            .current_dir(&self.working_dir)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .args(args)
            .spawn()
            .context("Could not spawn typst as a command")?;

        let max_compile_time = Duration::from_secs(10);
        let typst_output =
            match tokio::time::timeout(max_compile_time, typst_process.wait_with_output()).await {
                Ok(Ok(typst_output)) => Ok(typst_output),
                Ok(Err(e)) => Err(e).context("Typst process run into a error"),
                Err(e) => Err(e).context("Compilation did not finish within timeout limit"),
            }?;

        // Typst compilation failed
        if !typst_output.status.success() {
            let typst_error_output = &String::from_utf8_lossy(&typst_output.stderr)[..];
            tracing::warn!(typst_error_output, "Typst compilation failed with error");
            anyhow::bail!("Typst compilation failed with error")
        }

        Ok(typst_output.stdout)
    }
}

#[instrument]
fn build_cli_args(
    input_file: &str,
    output_format: TypstOutput,
    inputs: &HashMap<String, String>,
) -> Vec<String> {
    let mut args = vec![
        "compile".to_string(),
        "--format".to_string(),
        output_format.as_cli_arg().to_string(),
    ];

    // Append the input parameters to the args
    for (key, value) in inputs.iter() {
        args.push("--input".to_string());
        args.push(format!("{key}={value}"));
    }

    // Use STDIN as the input file
    args.push(input_file.to_string());

    // Use STDOUT as the output file
    args.push("/dev/stdout".to_string());

    args
}
